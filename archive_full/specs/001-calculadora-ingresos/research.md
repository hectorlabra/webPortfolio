# Research Findings: Calculadora de Ingresos

_Phase 0 Research Output - Generated by /plan command_

## Executive Summary

Research completed for calculator comparing one-time vs recurring revenue models. All technical unknowns resolved with practical, maintainable solutions chosen.

## Research Decisions

### 1. Financial Calculation Formulas

**Decision**: Implement standard SaaS financial formulas with TypeScript validation
**Rationale**:

- LTV = (Monthly Revenue × Gross Margin) / (Churn Rate + Discount Rate)
- Payback Period = Initial Investment / Monthly Profit
- Break-even = Point where cumulative subscription profit exceeds one-time profit
- Formulas validated against industry standards (SaaStr, ProfitWell)

**Alternatives Considered**:

- Complex NPV models (rejected: too complex for target audience)
- Monte Carlo simulation (rejected: overkill for MVP)
- Simple ROI only (rejected: doesn't show time-value of money)

### 2. Chart Visualization Approach

**Decision**: Recharts with responsive design and accessibility
**Rationale**:

- Bar charts for revenue comparison (clear, direct comparison)
- Line charts for cumulative growth over time
- Area charts for profit visualization
- Mobile-responsive with touch interactions
- WCAG AA compliance for accessibility

**Alternatives Considered**:

- D3.js (rejected: steeper learning curve, heavier bundle)
- Chart.js (rejected: less React-optimized)
- Custom SVG (rejected: maintenance overhead)

### 3. Form Validation Strategy

**Decision**: Zod schemas with React Hook Form and real-time validation
**Rationale**:

- Type-safe validation schemas matching TypeScript interfaces
- Real-time feedback prevents invalid calculations
- Currency formatting with proper locale support
- Percentage validation with bounds checking
- Custom error messages in Spanish

**Alternatives Considered**:

- Manual validation (rejected: error-prone, repetitive)
- Yup (rejected: Zod has better TypeScript integration)
- No validation (rejected: poor UX for financial calculator)

### 4. Local Storage Persistence

**Decision**: JSON serialization with schema versioning and error handling
**Rationale**:

- Automatic save on input changes (debounced)
- Schema versioning for future updates
- Graceful degradation if storage unavailable
- Privacy-compliant (no personal data sent to server)
- Cross-tab synchronization

**Alternatives Considered**:

- No persistence (rejected: poor UX, users lose work)
- Server-side storage (rejected: adds complexity, privacy concerns)
- Cookies (rejected: size limits, less reliable)

### 5. Performance Optimization Strategy

**Decision**: React.memo + useMemo + debouncing for calculation-heavy operations
**Rationale**:

- Calculations run only when inputs change
- Chart re-renders optimized with memoization
- Input debouncing prevents excessive recalculations
- Memory-efficient for large time horizons (up to 60 months)

**Alternatives Considered**:

- No optimization (rejected: poor performance on mobile)
- Web Workers (rejected: overkill for math operations)
- Pre-computed results (rejected: too many variables)

## Technical Specifications

### Calculation Engine

- **Precision**: 2 decimal places for currency, 4 for percentages
- **Time Horizon**: 1-60 months (configurable)
- **Churn Rate Bounds**: 0-50% (realistic SaaS ranges)
- **Discount Rate**: 8-15% (standard business valuation)

### UI/UX Patterns

- **Input Validation**: Real-time with contextual help
- **Results Display**: Progressive disclosure (summary → details)
- **Chart Interactions**: Hover tooltips, legend toggles
- **Mobile First**: Touch-friendly controls, responsive charts

### Error Handling

- **Input Errors**: Field-level validation with suggestions
- **Calculation Errors**: Graceful fallbacks with user notifications
- **Storage Errors**: Silent degradation, no data loss

## Implementation Guidelines

### Code Organization

- Pure functions for calculations (easy to test)
- Custom hooks for state management
- Component composition for UI flexibility
- Utility functions for formatting/display

### Testing Strategy

- Unit tests for all calculation functions
- Component tests for user interactions
- Integration tests for complete flows
- Performance tests for large datasets

### Accessibility

- Semantic HTML structure
- ARIA labels for charts and forms
- Keyboard navigation support
- Screen reader friendly

## Risk Assessment

- **Low Risk**: Standard React/TypeScript patterns
- **Medium Risk**: Financial calculation accuracy (mitigated by validation)
- **Low Risk**: Chart performance (Recharts is optimized)
- **Low Risk**: Local storage compatibility (broad browser support)

## Next Steps

Proceed to Phase 1: Design detailed component specifications and integration contracts based on these research findings.</content>
<parameter name="filePath">/Users/hectorignaciolabrabarros/Documents/Programacion/personales/webPortfolio/specs/001-calculadora-ingresos/research.md
